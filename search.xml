<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis笔记</title>
      <link href="/2022/11/02/Redis/"/>
      <url>/2022/11/02/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p><a href="https://registry.hub.docker.com/_/redis">https://registry.hub.docker.com/_/redis</a></p><ol><li><strong>准备 redis.conf</strong></li></ol><p>从官网下载<a href="https://link.juejin.cn/?target=http://download.redis.io/redis-stable/redis.conf">redis.conf</a>文件，点击超链接下载</p><p>redis官网：<a href="https://redis.io/">https://redis.io/</a></p><p>进入官网，直接下载 redis-xxx.tar.gz，然后解压也可以得到redis.conf</p><p>将redis.conf放在本地的一个目录,比如: D:&#x2F;redis. 并对文件做一下修改:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 #注释掉这部分，这是限制redis只能本地访问</span><br><span class="line">protected-mode no #默认yes，开启保护模式，限制为本地访问</span><br><span class="line">daemonize no#默认no，改为yes意为以守护进程方式启动，可后台运行，除非kill进程，改为yes会使配置文件方式启动redis失败</span><br><span class="line">databases 16 #数据库个数（可选），我修改了这个只是查看是否生效。。</span><br><span class="line">dir  ./ #输入本地redis数据库存放文件夹（可选）</span><br><span class="line">appendonly yes #redis持久化（可选）</span><br><span class="line">requirepass  密码 #配置redis访问密码</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>拉取镜像</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br><span class="line">docker pull redis</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><ol start="3"><li>在D:&#x2F;redis目录下面新建data目录,用于存储redis数据</li><li>启动redis镜像(配置和数据映射到本地)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name redis-server -p 6379:6379 -v D:\Software\Redis\conf:/etc/redis -v D:\Software\Redis\data:/data redis:latest redis-server /etc/redis/redis.conf --appendonly yes --requirepass &quot;123456&quot;</span><br></pre></td></tr></table></figure><blockquote><p>ps: 上面的命令里面,第一个<code>-v</code>是将redis.conf映射到docker的redis配置,第二个<code>-v</code>是将redis存储数据做映射.这里<code>:</code>前面的路径都是本地的路径,不要弄错了</p><p>redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf：指定容器启动时执行的命令</p><p>–appendonly yes 开启数据持久化,</p><p> –requirepass “123456” 指定密码</p><p>这些配置回被记录在容器内部docker inspect 容器名查看</p><p>实验发现, 如果在配置文件修改这些配置，重启redis后依然不会生效，只有在启动时不加这些参数，才会有效</p></blockquote><ol start="5"><li>查看</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker exec -it redis-server /bin/bash</span><br><span class="line">redis-cli -a 123456</span><br></pre></td></tr></table></figure><h3 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h3><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 <strong>redis.conf</strong>(Windows 名为 redis.windows.conf)。</p><p>你可以通过 <strong>CONFIG</strong> 命令查看或设置配置项。</p><p>语法</p><p>Redis CONFIG 命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></figure><p>使用 ***** 号获取所有配置项：</p><p><strong>编辑配置</strong></p><p>你可以通过修改 redis.conf 文件或使用 <strong>CONFIG set</strong> 命令来修改配置。</p><p>语法</p><p><strong>CONFIG SET</strong> 命令基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><p>redis.conf 配置项说明如下：</p><table><thead><tr><th align="left">序号</th><th align="left">配置项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><code>daemonize no</code></td><td align="left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td></tr><tr><td align="left">2</td><td align="left"><code>pidfile /var/run/redis.pid</code></td><td align="left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 &#x2F;var&#x2F;run&#x2F;redis.pid 文件，可以通过 pidfile 指定</td></tr><tr><td align="left">3</td><td align="left"><code>port 6379</code></td><td align="left">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td></tr><tr><td align="left">4</td><td align="left"><code>bind 127.0.0.1</code></td><td align="left"><strong>绑定的主机地址</strong>，默认只有本地可以访问</td></tr><tr><td align="left">5</td><td align="left"><code>timeout 300</code></td><td align="left">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td></tr><tr><td align="left">6</td><td align="left"><code>loglevel notice</code></td><td align="left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td></tr><tr><td align="left">7</td><td align="left"><code>logfile stdout</code></td><td align="left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 &#x2F;dev&#x2F;null</td></tr><tr><td align="left">8</td><td align="left"><code>databases 16</code></td><td align="left">设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td></tr><tr><td align="left">9</td><td align="left"><code>save &lt;seconds&gt; &lt;changes&gt;</code>Redis 默认配置文件中提供了三个条件：<strong>save 900 1<strong><strong>save 300 10</strong></strong>save 60 10000</strong>分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</td><td align="left">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td></tr><tr><td align="left">10</td><td align="left"><code>rdbcompression yes</code></td><td align="left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td></tr><tr><td align="left">11</td><td align="left"><code>dbfilename dump.rdb</code></td><td align="left">指定本地数据库文件名，默认值为 dump.rdb</td></tr><tr><td align="left">12</td><td align="left"><code>dir ./</code></td><td align="left">指定本地数据库存放目录</td></tr><tr><td align="left">13</td><td align="left"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td><td align="left">设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td></tr><tr><td align="left">14</td><td align="left"><code>masterauth &lt;master-password&gt;</code></td><td align="left">当 master 服务设置了密码保护时，slave 服务连接 master 的密码</td></tr><tr><td align="left">15</td><td align="left"><code>requirepass foobared</code></td><td align="left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</td></tr><tr><td align="left">16</td><td align="left"><code> maxclients 128</code></td><td align="left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td></tr><tr><td align="left">17</td><td align="left"><code>maxmemory &lt;bytes&gt;</code></td><td align="left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td></tr><tr><td align="left">18</td><td align="left"><code>appendonly no</code></td><td align="left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td></tr><tr><td align="left">19</td><td align="left"><code>appendfilename appendonly.aof</code></td><td align="left">指定更新日志文件名，默认为 appendonly.aof</td></tr><tr><td align="left">20</td><td align="left"><code>appendfsync everysec</code></td><td align="left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td></tr><tr><td align="left">21</td><td align="left"><code>vm-enabled no</code></td><td align="left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td></tr><tr><td align="left">22</td><td align="left"><code>vm-swap-file /tmp/redis.swap</code></td><td align="left">虚拟内存文件路径，默认值为 &#x2F;tmp&#x2F;redis.swap，不可多个 Redis 实例共享</td></tr><tr><td align="left">23</td><td align="left"><code>vm-max-memory 0</code></td><td align="left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td></tr><tr><td align="left">24</td><td align="left"><code>vm-page-size 32</code></td><td align="left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td></tr><tr><td align="left">25</td><td align="left"><code>vm-pages 134217728</code></td><td align="left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td></tr><tr><td align="left">26</td><td align="left"><code>vm-max-threads 4</code></td><td align="left">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td></tr><tr><td align="left">27</td><td align="left"><code>glueoutputbuf yes</code></td><td align="left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td></tr><tr><td align="left">28</td><td align="left"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td><td align="left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td></tr><tr><td align="left">29</td><td align="left"><code>activerehashing yes</code></td><td align="left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td></tr><tr><td align="left">30</td><td align="left"><code>include /path/to/local.conf</code></td><td align="left">指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td></tr></tbody></table><h3 id="3、常用五大数据类型"><a href="#3、常用五大数据类型" class="headerlink" title="3、常用五大数据类型"></a>3、常用五大数据类型</h3><p>redis常见数据类型操作命令<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><p>Redis 数据库支持五种数据类型。</p><ul><li>字符串（string）</li><li>哈希（hash）</li><li>列表（list）</li><li>集合（set）</li><li>有序集合（sorted set）</li><li>位图 ( Bitmaps )</li><li>基数统计 ( HyperLogLogs )</li></ul><h4 id="2-1命令"><a href="#2-1命令" class="headerlink" title="2.1命令"></a>2.1命令</h4><p>要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。</p><p>语法</p><p>Redis 客户端的基本语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure><p>实例</p><p>以下实例讲解了如何启动 redis 客户端：</p><p>启动 redis 服务器，打开终端并输入命令 <strong>redis-cli</strong>，该命令会连接本地的 redis 服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line"></span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>在以上实例中我们连接到本地的 redis 服务并执行 <strong>PING</strong> 命令，该命令用于检测 redis 服务是否启动。</p><p>在远程服务上执行命令</p><p>如果需要在远程 redis 服务上执行命令，同样我们使用的也是 <strong>redis-cli</strong> 命令。</p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure><p>实例</p><p>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line"></span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h4 id="2-2键"><a href="#2-2键" class="headerlink" title="2.2键"></a>2.2键</h4><ul><li>keys * 查看当前库所有key</li><li>exists key 判断某个key是否存在</li><li>type key 查看key是什么类型</li><li>del key 删除指定的key数据</li><li>unlink key 删除指定的key，该命令会执行命令之外的线程中执行实际的内存回收，因此它不是阻塞，而 <a href="https://www.redis.com.cn/commands/del.html">DEL</a> 是阻塞的，仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li><li>expire key 10 10s 为给定的key设置国企时间</li><li>ttl key 查看还有多少秒过期，-1表示永久不过期，-2表示已过期，默认是容不过期</li></ul><h4 id="2-1字符串"><a href="#2-1字符串" class="headerlink" title="2.1字符串"></a>2.1字符串</h4><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含<strong>任何数据</strong>。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。动态扩容</p><p><strong>常用命令</strong></p><p>下表列出了常用的 redis 字符串命令：</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/strings-set.html">SET key value</a> 设置指定 key 的值。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/strings-get.html">GET key</a> 获取指定 key 的值。</td></tr><tr><td align="left">3</td><td align="left"><strong>MSET key value [key value …]</strong> 同时设置一个或多个 key-value 对。</td></tr><tr><td align="left">4</td><td align="left"><strong>MGET key1 [key2..]</strong> 获取所有(一个或多个)给定 key 的值。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/redis/strings-strlen.html"><strong>STRLEN key</strong></a> 返回 key 所储存的字符串值的长度。</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/strings-incr.html"><strong>INCR key</strong></a> 将 key 中储存的数字值增一。</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/redis/strings-decr.html"><strong>DECR key</strong></a> 将 key 中储存的数字值减一。</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/redis/strings-incrby.html">INCRBY key increment</a> 将 key 所储存的值加上给定的增量值（increment） 。</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/redis/strings-decrby.html">DECRBY key decrement</a> key 所储存的值减去给定的减量值（decrement） 。</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/redis/strings-getset.html">GETSET key value</a> 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/redis/strings-setbit.html">SETBIT key offset value</a> 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。<strong>这两个在bitmap中使用</strong></td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/redis/strings-getbit.html">GETBIT key offset</a> 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/redis/strings-setex.html">SETEX key seconds value</a> 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/redis/strings-setnx.html">SETNX key value</a> 只有在 key 不存在时设置 key 的值。</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/redis/strings-setrange.html">SETRANGE key offset value</a> 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。（<strong>索引从0****开始</strong>)</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/redis/strings-getrange.html"><strong>GETRANGE</strong> key start end</a> 返回 key 中字符串值的子字符，<strong>左闭右闭</strong></td></tr><tr><td align="left">17</td><td align="left"><strong>MSETNX</strong> key value [key value …] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<strong>原子性，有一个失败则都失败</strong></td></tr><tr><td align="left">18</td><td align="left">APPEND key value 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td></tr><tr><td align="left">19</td><td align="left"><a href="https://www.runoob.com/redis/strings-psetex.html">PSETEX key milliseconds value</a> 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td></tr><tr><td align="left">20</td><td align="left"><a href="https://www.runoob.com/redis/strings-incrbyfloat.html">INCRBYFLOAT key increment</a> 将 key 所储存的值加上给定的浮点增量值（increment） 。</td></tr></tbody></table><p>应用场景：</p><p><strong>缓存对象</strong></p><p>使用 String 来缓存对象有两种方式：</p><ul><li>直接缓存整个对象的 JSON，命令例子： <code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#39;</code>。</li><li>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code>。</li></ul><p><strong>常规计数</strong></p><p><strong>分布式锁</strong></p><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><p>一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure><ul><li>lock_key 就是 key 键；</li><li>unique_value 是客户端生成的唯一的标识；</li><li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li><li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li></ul><p>而解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p><p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p><h4 id="2-2Hash"><a href="#2-2Hash" class="headerlink" title="2.2Hash"></a>2.2Hash</h4><p>Redis hash 是一个键值(key&#x3D;&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><p><strong>常用命令</strong></p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hset.html"><strong>HSET key field value</strong></a> 将哈希表 key 中的字段 field 的值设为 value 。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hget.html">HGET key field</a> 获取存储在哈希表中指定字段的值。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hmset.html"><strong>HMSET key field1 value1 field2 value2</strong> </a> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hmget.html"><strong>HMGET key field1 field2</strong></a> 获取所有给定字段的值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hexists.html"><strong>HEXISTS key field</strong></a> 查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hkeys.html"><strong>HKEYS key</strong></a> 获取所有哈希表中的字段</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hvals.html"><strong>HVALS key</strong></a> 获取哈希表中所有值。</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hincrby.html"><strong>HINCRBY key field increment</strong></a> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hsetnx.html"><strong>HSETNX key field value</strong></a> 只有在字段 field <code>不存在时</code>，设置哈希表字段的值。</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hdel.html">HDEL key field1 field2</a> 删除一个或多个哈希表字段</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hgetall.html">HGETALL key</a> 获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hincrbyfloat.html">HINCRBYFLOAT key field increment</a> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hlen.html">HLEN key</a> 获取哈希表中字段的数量</td></tr><tr><td align="left">14</td><td align="left">[HSCAN key cursor <a href="https://www.runoob.com/redis/hashes-hscan.html">MATCH pattern] [COUNT count]</a> 迭代哈希表中的键值对。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HMSET user:1 username ajeet password javatpoint alexa 2000  </span><br><span class="line">OK  </span><br><span class="line">HGETALL  user:1  </span><br><span class="line">&quot;username&quot;  </span><br><span class="line">&quot;ajeet&quot;  </span><br><span class="line">&quot;password&quot;  </span><br><span class="line">&quot;javatpoint&quot;  </span><br><span class="line">&quot;alexa&quot;  </span><br><span class="line">&quot;2000&quot; </span><br></pre></td></tr></table></figure><p>这里，HMSET 和 HGETALL 是 Redis 的命令，而 user:1 是键。</p><p>每个哈希可以存储多达 2^32^-1个字段-值对（40多亿）。</p><p>数据结构</p><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p><ul><li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p><h4 id="2-3列表list"><a href="#2-3列表list" class="headerlink" title="2.3列表list"></a>2.3列表list</h4><p>Redis 列表定义为字符串列表，按<strong>插入顺序排序</strong>。可以将元素添加到 Redis 列表的头部或尾部。</p><p>列表的最大长度为 <code>2^32 - 1</code>，也即每个列表支持超过 <code>40 亿</code>个元素。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lpush k1 redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush k1 mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush k1 rabbitmq</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange k1 0 10</span><br><span class="line">1) &quot;rabbitmq&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong></p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/lists-lpush.html"><strong>LPUSH key value1 value2</strong></a> 将一个或多个值插入到列表头部</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/lists-rpush.html"><strong>RPUSH key value1 value2</strong></a> 在列表中添加一个或多个值</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/lists-lpop.html"><strong>LPOP key</strong></a> 移出并获取列表的第一个元素</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/lists-rpop.html"><strong>RPOP key</strong></a> 移除列表的最后一个元素，返回值为移除的元素。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/redis/lists-blpop.html"><strong>BLPOP key1 [key2]  timeout</strong></a> 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/lists-brpop.html"><strong>BRPOP key1 [key2]  timeout</strong></a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/redis/lists-brpoplpush.html">BRPOPLPUSH source destination timeout</a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/redis/lists-lindex.html"><strong>LINDEX key index</strong></a> 通过索引获取列表中的元素</td></tr><tr><td align="left">9</td><td align="left"><strong>LRANGE key start stop</strong>获取列表指定范围内的元素 ,<strong>-1</strong>可以代表最后一个</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/redis/lists-llen.html"><strong>LLEN key</strong></a> 获取列表长度</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/redis/lists-linsert.html"><strong>LINSERT key BEFORE|AFTER pivot value</strong></a> 在列表的元素前或者后插入元素</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/redis/lists-lset.html"><strong>LSET key index value</strong></a> 通过索引设置列表元素的值</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/redis/lists-lrem.html"><strong>LREM key count value</strong></a> 移除列表元素，count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。count &lt; 0 : 从表尾开始向表头搜索；count &#x3D; 0 : 移除表中所有与 VALUE 相等的值。</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/redis/lists-lpushx.html">LPUSHX key value</a> 将一个值插入到已存在的列表头部</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/redis/lists-rpushx.html">RPUSHX key value</a> 为已存在的列表添加值</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/redis/lists-ltrim.html">LTRIM key start stop</a> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/redis/lists-rpoplpush.html">RPOPLPUSH source destination</a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr></tbody></table><p><strong>数据结构</strong></p><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p><p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><p>应用场景</p><p><a href="https://xiaolincoding.com/redis/data_struct/command.html#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></p><h4 id="2-4集合set"><a href="#2-4集合set" class="headerlink" title="2.4集合set"></a>2.4集合set</h4><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>集合对象的编码可以是 intset 或者 hashtable。</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD w3ckey mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS w3ckey</span><br><span class="line"> </span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong></p><p>下表列出了 Redis 集合基本命令：</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>SADD key member1 [member2]</strong> 向集合添加一个或多个成员</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.redis.net.cn/order/3603.html"><strong>SPOP key</strong> [count] </a> 移除并返回集合中的一个随机元素，可以实现抽奖功能，加count就是移除count个</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.redis.net.cn/order/3595.html"><strong>SCARD key</strong></a> 获取集合的成员数</td></tr><tr><td align="left">12</td><td align="left"><strong>SREM key member1 [member2]</strong> 移除集合中一个或多个成员</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.redis.net.cn/order/3601.html"><strong>SMEMBERS key</strong></a> 返回集合中的所有成员</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.redis.net.cn/order/3600.html"><strong>SISMEMBER key member</strong></a> 判断 member 元素是否是集合 key 的成员</td></tr><tr><td align="left">11</td><td align="left"><strong>SRANDMEMBER key [count]</strong> 返回集合中随机选出count个元素，<code>元素不会从key中删除</code></td></tr><tr><td align="left">3</td><td align="left">SDIFF key1 [key2] 返回给定所有集合的差集</td></tr><tr><td align="left">4</td><td align="left">SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td align="left">5</td><td align="left">SINTER key1 [key2] 返回给定所有集合的交集</td></tr><tr><td align="left">6</td><td align="left">SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.redis.net.cn/order/3602.html">SMOVE source destination member</a> 将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td align="left">13</td><td align="left">SUNION key1 [key2] 返回所有给定集合的并集</td></tr><tr><td align="left">14</td><td align="left">SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中</td></tr><tr><td align="left">15</td><td align="left">[SSCAN key cursor <a href="https://www.redis.net.cn/order/3608.html">MATCH pattern] [COUNT count]</a> 迭代集合中的元素</td></tr></tbody></table><p>内部实现</p><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><p><strong>应用场景</strong></p><p><strong>点赞</strong></p><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</p><p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:1 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:2 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:2</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:3 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:3</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><code>uid:1</code> 取消了对 article:1 文章点赞。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SREM article:1 uid:1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>获取 article:1 文章所有点赞用户 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SMEMBERS article:1</span></span><br><span class="line">1) &quot;uid:3&quot;</span><br><span class="line">2) &quot;uid:2&quot;</span><br></pre></td></tr></table></figure><p>获取 article:1 文章的点赞用户数量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SCARD article:1</span></span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>判断用户 <code>uid:1</code> 是否对文章 article:1 点赞了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER article:1 uid:1</span></span><br><span class="line">(integer) 0  # 返回0说明没点赞，返回1则说明点赞了</span><br></pre></td></tr></table></figure><p><strong>共同关注</strong></p><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p><p>key 可以是用户id，value 则是已关注的公众号的id。</p><p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:1 用户关注公众号 <span class="built_in">id</span> 为 5、6、7、8、9</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD uid:1 5 6 7 8 9</span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:2  用户关注公众号 <span class="built_in">id</span> 为 7、8、9、10、11</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD uid:2 7 8 9 10 11</span></span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><p><code>uid:1</code> 和 <code>uid:2</code> 共同关注的公众号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取共同关注</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SINTER uid:1 uid:2</span></span><br><span class="line">1) &quot;7&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;9&quot;</span><br></pre></td></tr></table></figure><p>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SDIFF uid:1 uid:2</span></span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;6&quot;</span><br></pre></td></tr></table></figure><p>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER uid:1 5</span></span><br><span class="line">(integer) 1 # 返回0，说明关注了</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER uid:2 5</span></span><br><span class="line">(integer) 0 # 返回0，说明没关注</span><br></pre></td></tr></table></figure><p><strong>抽奖活动</strong></p><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p><p>key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark</span></span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><p>如果允许重复中奖，可以使用 SRANDMEMBER 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取 1 个一等奖：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 1</span></span><br><span class="line">1) &quot;Tom&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取 2 个二等奖：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 2</span></span><br><span class="line">1) &quot;Mark&quot;</span><br><span class="line">2) &quot;Jerry&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取 3 个三等奖：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky 3</span></span><br><span class="line">1) &quot;Sary&quot;</span><br><span class="line">2) &quot;Tom&quot;</span><br><span class="line">3) &quot;Jerry&quot;</span><br></pre></td></tr></table></figure><p>如果不允许重复中奖，可以使用 SPOP 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取一等奖1个</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 1</span></span><br><span class="line">1) &quot;Sary&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取二等奖2个</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 2</span></span><br><span class="line">1) &quot;Jerry&quot;</span><br><span class="line">2) &quot;Mark&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取三等奖3个</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP lucky 3</span></span><br><span class="line">1) &quot;John&quot;</span><br><span class="line">2) &quot;Sean&quot;</span><br><span class="line">3) &quot;Lindy&quot;</span><br></pre></td></tr></table></figure><h4 id="2-5有序集合sorted-set"><a href="#2-5有序集合sorted-set" class="headerlink" title="2.5有序集合sorted set"></a>2.5有序集合sorted set</h4><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 2^32^ - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES</span><br><span class="line"></span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;mongodb&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;mysql&quot;</span><br><span class="line">6) &quot;4&quot;</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong></p><p>下表列出了 redis 有序集合的基本命令:</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>ZADD key score1 member1 [score2 member2]</strong> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.redis.net.cn/order/3610.html"><strong>ZCARD key</strong></a> 获取有序集合的成员数</td></tr><tr><td align="left">11</td><td align="left"><strong>ZREM key member [member …]</strong> 移除有序集合中的一个或多个成员</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.redis.net.cn/order/3626.html"><strong>ZSCORE key member</strong></a> 返回有序集中，成员的分数值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.redis.net.cn/order/3612.html"><strong>ZINCRBY key increment member</strong></a> 有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td align="left">7</td><td align="left"><strong>ZRANGE key start stop [WITHSCORES]</strong> 通过索引区间返回有序集合成指定区间内的成员</td></tr><tr><td align="left">8</td><td align="left"><strong>ZRANGEBYLEX key min max [LIMIT offset count]</strong> 通过字典区间返回有序集合的成员</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.redis.net.cn/order/3617.html"><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count</strong>]</a> 通过分数返回有序集合指定区间内的成员</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.redis.net.cn/order/3620.html">ZREMRANGEBYLEX key min max</a> 移除有序集合中给定的字典区间的所有成员</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.redis.net.cn/order/3622.html">ZREMRANGEBYSCORE key min max</a> 移除有序集合中给定的分数区间的所有成员</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.redis.net.cn/order/3621.html">ZREMRANGEBYRANK key start stop</a> 移除有序集合中给定的排名区间的所有成员</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.redis.net.cn/order/3611.html">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</td></tr><tr><td align="left">5</td><td align="left">ZINTERSTORE destination numkeys key [key …] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td align="left">19</td><td align="left">ZUNIONSTORE destination numkeys key [key …]计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.redis.net.cn/order/3614.html">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.redis.net.cn/order/3618.html">ZRANK key member</a> 返回有序集合中指定成员的索引</td></tr><tr><td align="left">15</td><td align="left">ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到底</td></tr><tr><td align="left">16</td><td align="left">ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.redis.net.cn/order/3625.html">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td align="left">20</td><td align="left">[ZSCAN key cursor <a href="https://www.redis.net.cn/order/3628.html">MATCH pattern] [COUNT count]</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><p>内部实现</p><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p><p><strong>应用场景</strong></p><p><strong>排行榜</strong></p><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p><p><strong>电话、姓名排序</strong></p><p>使用有序集合的 <code>ZRANGEBYLEX</code> 或 <code>ZREVRANGEBYLEX</code> 可以帮助我们实现电话号码或姓名的排序，我们以 <code>ZRANGEBYLEX</code> （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。</p><p><strong>注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</strong></p><h4 id="2-6-新数据类型"><a href="#2-6-新数据类型" class="headerlink" title="2.6 新数据类型"></a>2.6 新数据类型</h4><h6 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a><strong>Bitmaps</strong></h6><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><p>（1）  Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p><p>（2）  Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p><p>常用命令                       作用</p><p>1、<code>getbit key offset</code>   用于获取指定key对应的值，中对应offset的bit ，对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0</p><p>2、<code>setbit key offset value</code> 用于修改指定key对应的值，中对应offset的bit</p><p>3、 <code>bitcount key [start end]</code>   用于统计字符串被设置为1的bit数</p><p>4、<code>bitop and/or/xor/not destkey key [key …]</code> 用于一个或对多个key求逻辑与&#x2F;逻辑或&#x2F;逻辑异或&#x2F;逻辑非，并将结果保存到 destkey 上</p><p>BITOP AND destkey key [key …] ，对一个或多个 key 求逻与，并将结果保存到 destkey</p><p>BITOP OR destkey key [key …] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey  全0为0，不全0为1</p><p>BITOP XOR destkey key [key …] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey  不同为1，相同为0</p><p>BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey  按位取反</p><p>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入，当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0，空的 key 也被看作是包含 0 的字符串序列</p><p>BITOP AND destkey key [key …]演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; setbit k1 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; setbit k2 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; bitop and k3 k1 k2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get k3</span><br><span class="line">&quot;\x00&quot;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-29777bd1e55114d2b6277123165c45f7_720w.jpg" alt="img"></p><p>​全1为1，不全1为0</p><p><strong>案例</strong></p><p>Redis 亿级用户信息存储实践：bitmap 位图存储</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2233022/811b1c3c2c73e86780e5c0560780beb4.png?imageView2/2/w/1620"></p><p>如果一个网站有1亿用户,假如user_id用的是整型,长度为32位,每天有5千万独立用户访问,如何判断是哪5千万用户访问了网站。</p><ul><li>方式一:用set来保存</li></ul><p>使用set来保存数据运行一天需要占用的内存为 32bit*50000000&#x3D;(4 * 50000000) &#x2F; 1024 &#x2F;1024 MB,约为200MB</p><p>运行一个月需要占用的内存为30 * 200 &#x3D; 6G，运行一年占用的内存为72G</p><ul><li>方式二：使用bitmap的方式</li></ul><p>user_id作为offset，如果user_id访问网站，则在user_id的索引上设置为1，没有访问网站的user_id，其索引设置为0，此种方式运行一天占用的内存为 1bit* 100000000 &#x3D; 100000000 &#x2F; 1024 &#x2F;1024&#x2F; 8MB，约为12.5MB 运行一个月占用的内存为375MB，一年占用的内存容量为4.5G</p><p>场景</p><p><strong>网站用户签到的天数统计</strong></p><p>用户ID为key，天作为offset，上线置为1 366&gt; 000000000000000</p><p>366 &#x2F;8&#x3D;46Byte ID为18的用户，今年的第1天签到、第30天签到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; setbit u18 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; setbit u18 30 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; bitcount u18 #统计id为18的用户签到总次数</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p><strong>按天统计网站活跃用户</strong></p><p>天作为key，用户ID为offset，上线置为1</p><p>一亿用户，运行一天占用的内存为 1bit* 100000000 &#x3D; 100000000 &#x2F; 1024 &#x2F;1024&#x2F; 8MB，约为12.5MB 运行一个月占用的内存为375MB，一年占用的内存容量为4.5G</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;SETBIT 20190601 5  1    #0000 0100</span><br><span class="line">&gt;SETBIT 20190602 7  1    #0000 0001 </span><br><span class="line">&gt;SETBIT 20190603 7  1    #0000 0001</span><br><span class="line"></span><br><span class="line">求6月1日到6月10日的活跃用户数</span><br><span class="line">&gt;BITOP OR users 20190601 20190602 20190603 ... 20190610</span><br><span class="line">&gt;BITCOUNT users    #目标key为users 结果为2</span><br></pre></td></tr></table></figure><p>用户在线状态、在线人数统计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; SETBIT online 5  1 #0000 0100 上线为1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; SETBIT online 7  1 #0000 0101</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; bitcount online #当前在线人数</span><br><span class="line">(integer) 2 </span><br><span class="line">&gt; SETBIT online 7  0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; bitcount online #当前在线人数</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h6 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis HyperLogLog"></a>Redis HyperLogLog</h6><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><h6 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h6><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</p><p>Redis GEO 操作方法有：</p><ul><li>geoadd：添加地理位置的坐标。</li><li>geopos：获取地理位置的坐标。</li><li>geodist：计算两个位置之间的距离。</li><li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li><li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li><li>geohash：返回一个或多个位置对象的 geohash 值。</li></ul><h3 id="4、发布订阅"><a href="#4、发布订阅" class="headerlink" title="4、发布订阅"></a>4、发布订阅</h3><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png" alt="img"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png" alt="img"></p><p>实例</p><p>以下实例演示了发布订阅是如何工作的，需要开启两个 redis-cli 客户端。</p><p>第一个 redis-cli 客户端（订阅者）</p><p>在我们实例中我们创建了订阅频道名为 <strong>runoobChat</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE runoobChat</span><br><span class="line"></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;runoobChat&quot;</span><br><span class="line">3)(integer) 1</span><br></pre></td></tr></table></figure><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 runoobChat 发布两次消息，订阅者就能接收到消息。</p><p>第二个 redis-cli 客户端（发布者）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Redis PUBLISH test&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Learn redis by runoob.com&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>\订阅者的客户端会显示如下消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;runoobChat&quot;</span><br><span class="line">3) &quot;Redis PUBLISH test&quot;</span><br><span class="line"></span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;runoobChat&quot;</span><br><span class="line">3) &quot;Learn redis by runoob.com&quot;</span><br></pre></td></tr></table></figure><p>gif 演示如下：</p><ul><li>开启本地 Redis 服务，开启两个 redis-cli 客户端。</li><li>在<strong>第一个 redis-cli 客户端</strong>输入 <strong>SUBSCRIBE runoobChat</strong>，意思是订阅 <code>runoobChat</code> 频道。</li><li>在<strong>第二个 redis-cli 客户端</strong>输入 <strong>PUBLISH runoobChat “Redis PUBLISH test”</strong> 往 runoobChat 频道发送消息，这个时候在第一个 redis-cli 客户端就会看到由第二个 redis-cli 客户端发送的测试消息。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2014/11/redis-pub-sub.gif" alt="img"></p><p>命令</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">PSUBSCRIBE pattern [pattern …] 订阅一个或多个符合给定模式的频道。</td></tr><tr><td align="left">2</td><td align="left">[PUBSUB subcommand <a href="https://www.runoob.com/redis/pub-sub-pubsub.html">argument [argument …]]</a> 查看订阅与发布系统状态。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/pub-sub-publish.html">PUBLISH channel message</a> 将信息发送到指定的频道。</td></tr><tr><td align="left">4</td><td align="left">[PUNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-punsubscribe.html">pattern [pattern …]]</a> 退订所有给定模式的频道。</td></tr><tr><td align="left">5</td><td align="left">SUBSCRIBE channel [channel …] 订阅给定的一个或多个频道的信息。</td></tr><tr><td align="left">6</td><td align="left">[UNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-unsubscribe.html">channel [channel …]]</a> 指退订给定的频道。</td></tr></tbody></table><h3 id="5、Java-使用-Redis-Jedis"><a href="#5、Java-使用-Redis-Jedis" class="headerlink" title="5、Java 使用 Redis(Jedis)"></a>5、Java 使用 Redis(Jedis)</h3><p><a href="https://www.runoob.com/redis/redis-java.html">案例</a></p><h3 id="6、Redis与Spring-Boot整合"><a href="#6、Redis与Spring-Boot整合" class="headerlink" title="6、Redis与Spring Boot整合"></a>6、<strong>Redis与Spring Boot整合</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>application.properties配置redis配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">192.168.140.136</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><p><strong>配置类</strong>，一般自定义配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单使用redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveRedis</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;springboot:redis:name&quot;</span>,<span class="string">&quot;promsing&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;springboot:redis:name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;redis中存储的内容&quot;</span>+o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> o.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = UserApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;<span class="comment">//存储的数据进行了序列化,建议使用它</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate2;<span class="comment">//存储的数据没有给序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 存储数据</span></span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.opsForValue().set(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.opsForValue().get(<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;val = &quot;</span> + val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 存储数据，并指定剩余生命时间,5小时</span></span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.opsForValue().set(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>,</span><br><span class="line">                <span class="number">5</span>, TimeUnit.HOURS); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        BoundHashOperations&lt;String, Object, Object&gt; hashOps =</span><br><span class="line">                <span class="built_in">this</span>.redisTemplate.boundHashOps(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">// 操作hash数据</span></span><br><span class="line">        hashOps.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        hashOps.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取单个数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> hashOps.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有数据</span></span><br><span class="line">        Map&lt;Object, Object&gt; map = hashOps.entries();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; me : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(me.getKey() + <span class="string">&quot; : &quot;</span> + me.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisTemplate.html">更多操作API</a></p><h3 id="7、Redis事务"><a href="#7、Redis事务" class="headerlink" title="7、Redis事务"></a>7、Redis事务</h3><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务。MULTI</li><li>命令入队。组队阶段出现错误，提交会失败</li><li>执行事务。EXEC</li></ul><p>实例</p><p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) 1) &quot;Mastering Series&quot;</span><br><span class="line">   2) &quot;C++&quot;</span><br><span class="line">   3) &quot;Programming&quot;</span><br></pre></td></tr></table></figure><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:6379&gt; INCR book_name</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:6379&gt; SET K2 V2</span><br><span class="line">QUEUE</span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">ok</span><br><span class="line">error #不会发生回滚</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>组队失败的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:6379&gt; SET K1 </span><br><span class="line">ERROR</span><br><span class="line">redis 127.0.0.1:6379&gt; SET K2 V2</span><br><span class="line">QUEUE</span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">ERROR</span><br></pre></td></tr></table></figure><p>下表列出了 redis 事务的相关命令：</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/transactions-discard.html">DISCARD</a> 取消事务，放弃执行事务块内的所有命令。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/transactions-exec.html">EXEC</a> 执行所有事务块内的命令。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/transactions-multi.html">MULTI</a> 标记一个事务块的开始。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/transactions-unwatch.html">UNWATCH</a> 取消 WATCH 命令对所有 key 的监视。</td></tr><tr><td align="left">5</td><td align="left">WATCH key [key …]监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。加了乐观锁</td></tr></tbody></table><blockquote><p>springboot整合redis的时候不要在事务中做查询，因为不会马上有结果</p></blockquote><h3 id="8、Redis脚本-Lua"><a href="#8、Redis脚本-Lua" class="headerlink" title="8、Redis脚本(Lua)"></a>8、Redis脚本(Lua)</h3><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 <strong>EVAL</strong>。</p><p>语法</p><p>Eval 命令的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></figure><p>实例</p><p>以下实例演示了 redis 脚本工作过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second</span><br><span class="line"></span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;first&quot;</span><br><span class="line">4) &quot;second&quot;</span><br></pre></td></tr></table></figure><p>Redis 脚本命令</p><p>下表列出了 redis 脚本常用命令：</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">[EVAL script numkeys key <a href="https://www.runoob.com/redis/scripting-eval.html">key …] arg [arg …]</a> 执行 Lua 脚本。</td></tr><tr><td align="left">2</td><td align="left">[EVALSHA sha1 numkeys key <a href="https://www.runoob.com/redis/scripting-evalsha.html">key …] arg [arg …]</a> 执行 Lua 脚本。</td></tr><tr><td align="left">3</td><td align="left">SCRIPT EXISTS script [script …]查看指定的脚本是否已经被保存在缓存当中。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/scripting-script-flush.html">SCRIPT FLUSH</a> 从脚本缓存中移除所有脚本。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/redis/scripting-script-kill.html">SCRIPT KILL</a> 杀死当前正在运行的 Lua 脚本。</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/scripting-script-load.html">SCRIPT LOAD script</a> 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td></tr></tbody></table><h3 id="9、持久化"><a href="#9、持久化" class="headerlink" title="9、持久化"></a>9、持久化</h3><h4 id="9-1-AOF"><a href="#9-1-AOF" class="headerlink" title="9.1 AOF"></a>9.1 AOF</h4><p>AOF 持久化记录服务器执行的<strong>所有写操作命令</strong>，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。AOF是写后日志，<strong>“写后”</strong>的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志,命令执行后才记录日志，所以不会阻塞当前的写操作。</p><p>如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</p><p>后写避免了对当前命令的阻塞，但可能会<code>给下一个操作带来阻塞风险</code>。这是因为，<strong>AOF 日志也是在主线程中执行的</strong>，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</p><p><code>Redis 还可以在后台对 AOF 文件进行重写（rewrite）</code>，使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</p><p>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会<strong>优先使用 AOF 文件来还原数据集</strong>， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</p><p>你可以通过修改配置文件来打开 AOF 功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p><strong>日志重写</strong></p><p>你可以猜得到，写操作不断执行的时候AOF文件会越来越大。例如，如果你增加一个计数器100次，你的数据集里只会有一个键存储这最终值，但是却有100条记录在AOF中。其中99条记录在重建当前状态时是不需要的。</p><p>于是Redis支持一个有趣的特性：在后台重建AOF而不影响服务客户端。每当你发送BGREWRITEAOF时，Redis将会写入一个新的AOF文件，包含重建当前内存中数据集所需的最短命令序列。如果你使用的是Redis 2.2的AOF，你需要不时的运行<code>BGREWRITEAOF</code>命令。Redis 2.4可以自动触发日志重写(查看Redis 2.4中的示例配置文件以获得更多信息)。</p><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p><p><strong>AOF3种写盘策略</strong></p><p>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。有三个选项：</p><ul><li>每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。</li><li>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会<code>丢失 1 秒钟</code>的数据。</li><li>从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。</li></ul><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。 总是 fsync 的策略在实际使用中非常慢， 即使在 Redis 2.0 对相关的程序进行了改进之后仍是如此 —— 频繁调用 fsync 注定了这种策略不可能快得起来。</p><p>当使用Always策略时，主线程执行完命令之后，会调用fsync()函数，把缓冲区的数据写入到硬盘的aof文件，等到硬盘操作往之后函数才会返回，如果写入的是一个大key，主线程在执行fsync()的时候就会被阻塞比较久。</p><blockquote><p>大key是指key对应的value很大</p><p>对于string类型 值&gt;10kb</p><p>hash list,set, zset 类型的元素个数超高5000个</p></blockquote><p><strong>如果 AOF 文件出错了，怎么办？</strong></p><p>服务器可能在程序正在对 AOF 文件进行写入时崩溃（这个不应该破坏数据的一致性）， Redis不会装载已破坏的AOF文件。当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</p><ul><li>为现有的 AOF 文件创建一个备份。</li><li>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。</li><li>$ redis-check-aof –fix</li><li>（可选）使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。</li><li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</li></ul><p><strong>重写如何工作</strong></p><p>日志重写采用了和快照一样的写时复制机制。下面是过程：</p><ul><li>Redis调用fork()。于是我们有了父子两个进程。</li><li>子进程开始向一个临时文件中写AOF。</li><li>父进程在一个内存缓冲区中积累新的变更(同时将新的变更写入旧的AOF文件，所以即使重写失败我们也安全)。</li><li>当子进程完成重写文件，父进程收到一个信号，追加内存缓冲区到子进程创建的文件末尾。</li><li>搞定！现在Redis原子性地重命名旧文件为新的，然后开始追加新数据到新文件。</li></ul><p>AOF重写是非阻塞的，和 AOF 日志由主线程写回不同，重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。</p><p>我把重写的过程总结为<strong>“一个拷贝，两处日志”</strong>。</p><p>“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>“两处日志”又是什么呢？</p><p>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。</p><p>而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。</p><p><img src="https://fastly.jsdelivr.net/gh/YuChaoM/images/OS/image-20220912153729399.png" alt="image-20220912153729399"></p><p><strong>AOF 的优点:</strong></p><ul><li>使用AOF Redis会更具有可持久性(durable)：你可以有很多不同的fsync策略：没有fsync，每秒fsync，每次请求时fsync。使用<strong>默认的每秒fsync</strong>策略，写性能也仍然很不错(fsync是由后台线程完成的，主线程继续努力地执行写请求)，即便你也就仅仅只损失一秒钟的写数据。</li><li>AOF日志是一个追加文件，所以不需要定位，在断电时也没有损坏问题。即使由于某种原因文件末尾是一个写到一半的命令(磁盘满或者其他原因),redis-check-aof工具也可以很轻易的修复。</li><li>当AOF文件变得很大时，Redis会自动在后台进行重写。重写是绝对安全的，因为Redis继续往旧的文件中追加，使用创建当前数据集所需的最小操作集合来创建一个全新的文件，一旦第二个文件创建完毕，Redis就会切换这两个文件，并开始往新文件追加。</li><li>AOF文件里面包含一个接一个的操作，以易于理解和解析的格式存储。你也可以轻易的导出一个AOF文件。例如，即使你不小心错误地使用FLUSHALL命令清空一切，如果此时并没有执行重写，你仍然可以保存你的数据集，你只要停止服务器，删除最后一条命令，然后重启Redis就可以。</li></ul><p><strong>AOF 的缺点:</strong></p><ul><li>对同样的数据集，AOF文件通常要大于等价的RDB文件。</li><li>AOF可能比RDB慢，这取决于准确的fsync策略。通常fsync设置为每秒一次的话性能仍然很高，如果关闭fsync，即使在很高的负载下也和RDB一样的快。不过，即使在很大的写负载情况下，RDB还是能提供能好的最大延迟保证。</li><li>在过去，我们经历了一些针对特殊命令(例如，像BRPOPLPUSH这样的阻塞命令)的罕见bug，导致在数据加载时无法恢复到保存时的样子。这些bug很罕见，我们也在测试套件中进行了测试，自动随机创造复杂的数据集，然后加载它们以检查一切是否正常，但是，这类bug几乎不可能出现在RDB持久化中。为了说得更清楚一点：Redis AOF是通过递增地更新一个已经存在的状态，像MySQL或者MongoDB一样，而RDB快照是一次又一次地从头开始创造一切，概念上更健壮。但是，1)要注意Redis每次重写AOF时都是以当前数据集中的真实数据从头开始，相对于一直追加的AOF文件(或者一次重写读取老的AOF文件而不是读内存中的数据)对bug的免疫力更强。2)我们还没有收到一份用户在真实世界中检测到崩溃的报告。</li></ul><h4 id="9-2-RDB-快照"><a href="#9-2-RDB-快照" class="headerlink" title="9.2 RDB 快照"></a>9.2 RDB 快照</h4><p>AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。这当然不是理想的结果。<code>RDB可以在宕机时实现快速恢复</code></p><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）</p><p>默认情况下，Redis保存数据集快照到磁盘，名为dump.rdb的二进制文件。你可以设置让Redis在N秒内至少有M次数据集改动时保存数据集，或者你也可以<strong>手动调用SAVE或者BGSAVE命令</strong>。</p><p>例如，这个配置会让Redis在每个60秒内至少有1000次键改动时自动转储数据集到磁盘：</p><blockquote><p>save 60 1000</p></blockquote><p>这种策略被称为快照。</p><p><strong>快照的运作方式:</strong></p><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：</p><ul><li>Redis 调用 fork() ，同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ul><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p><p>配置文件 redis.conf，服务重新启动时就会恢复数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.rdb #默认的数据备份文件名</span><br></pre></td></tr></table></figure><p>数据备份文件的位置，默认在安装目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG GET dir #输出dump.rdb文件的位置</span><br></pre></td></tr></table></figure><p>配置文件中的快照配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unless specified otherwise, by default Redis will save the DB:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  * After 3600 seconds (an hour) <span class="keyword">if</span> at least 1 change was performed</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  * After 300 seconds (5 minutes) <span class="keyword">if</span> at least 100 changes were performed</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  * After 60 seconds <span class="keyword">if</span> at least 10000 changes were performed</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># You can set these explicitly by uncommenting the following line.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># save 3600 1 300 100 60 10000</span></span></span><br></pre></td></tr></table></figure><p><strong>RDB 的优点:</strong></p><ul><li>RDB是一种表示某个即时点的Redis数据的紧凑文件。RDB文件适合用于备份。例如，你可能想要每小时归档最近24小时的RDB文件，每天保存近30天的RDB快照。这允许你很容易的恢复不同版本的数据集以容灾。</li><li>RDB非常适合于灾难恢复，作为一个紧凑的单一文件，可以被传输到远程的数据中心，或者是Amazon S3(可能得加密)。</li><li>RDB最大化了Redis的性能，因为Redis父进程持久化时唯一需要做的是启动(fork)一个子进程，由子进程完成所有剩余工作。父进程实例不需要执行像磁盘IO这样的操作。</li><li>RDB在重启保存了大数据集的实例时比AOF要快。</li></ul><p><strong>RDB 的缺点</strong></p><ul><li>当你需要在Redis停止工作(例如停电)时最小化数据丢失，RDB可能不太好。你可以配置不同的保存点(save point)来保存RDB文件(例如，5分钟之后至少对数据集100次写之后，但是你可以有多个保存点)。然而，你通常每隔5分钟或更久创建一个RDB快照，所以一旦Redis因为任何原因没有正确关闭而停止工作，你就得做好最近几分钟数据丢失的准备了。</li><li>RDB需要经常调用fork()子进程来持久化到磁盘。如果数据集很大的话，fork()比较耗时，结果就是，当数据集非常大并且CPU性能不够强大的话，Redis会停止服务客户端几毫秒甚至一秒。AOF也需要fork()，但是你可以调整多久频率重写日志而不会有损(trade-off)持久性(durability)。</li></ul><p>RDB 记录的是某一时刻的数据，并不是操作</p><p>我们还要考虑两个关键问题：</p><ul><li>对哪些数据做快照？这关系到快照的执行效率问题；</li><li>做快照时，数据还能被增删改吗？这关系到 Redis 是否被阻塞，能否同时正常处理请求。</li></ul><p><strong>给哪些内存数据做快照？</strong></p><p>Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是<code>全量快照</code>，也就<br>是说，把内存中的所有数据都记录到磁盘中.<br>对于 Redis 而言，它的单线程模型就决定了，我们要尽量避免所有会阻塞主线程的操作，</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p><ul><li>save：在主线程中执行，会导致阻塞；</li><li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是Redis RDB 文件生成的默认配置</li></ul><p><strong>快照时数据能修改吗?</strong></p><p>举个例子。我们在时刻 t 给内存做快照，假设内存数据量是 4GB，磁盘的写入带宽是0.2GB&#x2F;s，简单来说，至少需要 20s（4&#x2F;0.2 &#x3D; 20）才能做完。如果在时刻 t+5s 时，一个<code>还没有被写入磁盘</code>的内存数据 A，被修改成了 A’，那么就会破坏快照的完整性，因为A’不是时刻 t 时的状态。因此，和拍照类似，我们在做快照时也不希望数据“动”，也就是不能被修改。但是，如果快照执行期间数据不能被修改，Redis 就不能处理对这些数据的<code>写操作</code>，那无疑就会给业务服务造成巨大的影响。</p><p>为了保持写操作，Redis 就会借助操作系统提供的<strong>写时复制技术</strong>（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</p><p>简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</p><p>此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C，还未写磁盘），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p><p><img src="https://fastly.jsdelivr.net/gh/YuChaoM/images/OS/image-20220912162822300.png" alt="image-20220912162822300"></p><p><strong>多久做一次快照？</strong></p><p>如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。</p><p><img src="https://fastly.jsdelivr.net/gh/YuChaoM/images/OS/image-20220912163132682.png" alt="image-20220912163132682"></p><p>如果每秒做一次快照，<code>虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销。</code></p><p>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力。</p><p>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。</p><p>有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？</p><h5 id="混合使用-AOF-日志和内存快照"><a href="#混合使用-AOF-日志和内存快照" class="headerlink" title="混合使用 AOF 日志和内存快照"></a>混合使用 AOF 日志和内存快照</h5><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><p>T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。</p><p><img src="https://fastly.jsdelivr.net/gh/YuChaoM/images/OS/image-20220912163546708.png" alt="image-20220912163546708"></p><blockquote><p>开启：混合持久化的配置参数为 aof-use-rdb-preamble，配置为 yes 时开启混合持久化，在 redis 4 刚引入时，默认是关闭混合持久化的，但是在 <strong>redis 5 中默认已经打开了</strong>。</p></blockquote><h4 id="9-3-如何由RDB持久化转换到AOF持久化？"><a href="#9-3-如何由RDB持久化转换到AOF持久化？" class="headerlink" title="9.3 如何由RDB持久化转换到AOF持久化？"></a>9.3 如何由RDB持久化转换到AOF持久化？</h4><p>Redis 2.0 和 Redis 2.2 处理流程不一样，可以很简单猜测到 Redis 2.2 处理流程更简单，并且不需要重启。</p><p><strong>Redis &gt;&#x3D;2.2 时</strong></p><ul><li>创建最近的RDB文件的备份。</li><li>将备份保存在安全的位置。</li><li>发起如下命令。</li><li>$redis-cli config set appendonly yes。</li><li>$redis-cli config set save “”。</li><li>确认数据库包含相同的keys。</li><li>确认write操作被正确追加到了AOF文件。</li></ul><p>第一个CONFIG命令开启AOF。Redis会阻塞以生成初始转储文件，然后打开文件准备写，开始追加写操作。</p><p>第二个CONFIG命令用于关闭快照持久化。这一步是可选的，如果你想同时开启这两种持久化方法。</p><p><strong>重要：</strong>记得编辑你的redis.conf文件来开启AOF，否则当你重启服务器时，你的配置修改将会丢失，服务器又会使用旧的配置。</p><h3 id="10、主从复制"><a href="#10、主从复制" class="headerlink" title="10、主从复制"></a>10、主从复制</h3><p><a href="https://juejin.cn/post/6844903943764443149">搭建参考</a></p><p>Redis 具有高可靠性：一是数据尽量少丢失，二是服务尽量少中断。AOF 和 RDB 保证了前者，而对于后者，Redis 的做法就是增加副本冗余量，将一份数据同时保存在多个实例上。</p><p>实际上，Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。</p><ul><li>读操作：主库、从库都可以接收；</li><li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li></ul><p><img src="https://fastly.jsdelivr.net/gh/YuChaoM/images/OS/image-20220912195034424.png" alt="image-20220912195034424"></p><p>如果在上图中，不管是主库还是从库，都能接收客户端的写操作，那么，一个直接的问题就是：如果客户端对同一个数据（例如 k1）前后修改了三次，每一次的修改请求都发送到不同的实例上，在不同的实例上执行，那么，这个数据在这三个实例上的副本就不一致了（分别是 v1、v2 和 v3）</p><p>如果我们非要保持这个数据在三个实例上一致，就要涉及到加锁、实例间协商是否完成修改等一系列操作，但这会带来巨额的开销</p><p><strong>主从库间如何进行第一次同步？</strong></p><p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p><p>例如，现在有实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5），我们在实例 2 上执行以下这个命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 172.16.19.3 6379</span><br></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/YuChaoM/images/OS/image-20220912195509697.png" alt="image-20220912195509697"></p><p>主从级联模式分担全量复制时的主库压力</p><p>这就是“主 - 从 - 从”模式,我们可以通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</p><p><img src="https://fastly.jsdelivr.net/gh/YuChaoM/images/OS/image-20220912200657427.png" alt="image-20220912200657427"></p><p>我们了解了主从库间通过全量复制实现数据同步的过程，以及通过“主 -从 - 从”模式分担主库压力的方式。那么，一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为<strong>基于长连接的命令传播</strong>，可以避免频繁建立连接的开销。如果网络断连，主从库之间就无法进行命令传播了，从库的数据自然也就没办法和主库保持一致了，客户端就可能从从库读到旧数据。</p><p><strong>主从库间网络断了怎么办？</strong></p><p>在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大</p><p>从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。听名字大概就可以猜到它和全量复制的不同：<code>全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。</code></p><p>那么，增量复制时，主从库之间具体是怎么保持同步的呢？这里的奥妙就在于<code>repl_backlog_buffer</code> 这个缓冲区。我们先来看下它是如何用于增量命令的同步的。</p><p>当主从库断连后，主库会把断连期间收到的写操作命令，<code>写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区</code>。</p><p>repl_backlog_buffer 是一个环形缓冲区，<strong>主库会记录自己写到的位置，从库则会记录自己已经读到的位置。</strong></p><p>刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是 master_repl_offset。主库接收的新写操作越多，这个值就会越大。</p><p>同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏移量基本相等。</p><p><img src="https://fastly.jsdelivr.net/gh/YuChaoM/images/OS/image-20220912201550054.png" alt="image-20220912201550054"></p><p>主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset之间的差距。</p><p>在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset会大于 slave_repl_offset。此时，主库只用把 master_repl_offset 和 slave_repl_offset之间的命令操作同步给从库就行。</p><p><img src="https://fastly.jsdelivr.net/gh/YuChaoM/images/OS/image-20220912201646405.png" alt="image-20220912201646405"></p><p>因为 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。</p><p>一般而言，我们可以调整 repl_backlog_size 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小 &#x3D; 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即repl_backlog_size &#x3D; 缓冲空间大小 * 2，这也就是 repl_backlog_size 的最终值。</p><h3 id="11、哨兵"><a href="#11、哨兵" class="headerlink" title="11、哨兵"></a>11、哨兵</h3><h3 id="12、集群"><a href="#12、集群" class="headerlink" title="12、集群"></a>12、集群</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
